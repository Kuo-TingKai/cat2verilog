# cat2verilog

一個將範疇論描述語言轉換為 Verilog 硬體描述語言的工具。

## 專案概述

cat2verilog 是一個創新的 DSL（領域特定語言）工具，允許你使用範疇論的語法來描述邏輯電路，並自動生成可模擬的 Verilog 程式碼。這個工具特別適合：

- 函數式程式設計師想要設計硬體
- 數學家想要驗證範疇論的交換性
- 硬體工程師想要使用更高層次的抽象

## 功能特色

- [] **DSL Parser** - 解析範疇論語法
- [] **AST 建構** - 建立抽象語法樹
- [] **DAG 生成** - 將範疇論轉換為有向無環圖
- [] **Verilog 生成** - 自動產生可模擬的 Verilog 程式碼
- [] **交換性驗證** - 檢查交換圖是否 commute
- [] **CLI 工具** - 簡單的命令列介面

## 安裝與建置

### 前置需求

- Rust 1.70+ (使用 rustup 安裝)
- Cargo (Rust 套件管理器)

### 建置步驟

```bash
# 克隆專案
git clone <repository-url>
cd cat2verilog

# 建置專案
cargo build

# 執行測試
cargo test
```

## 使用方式

### 基本語法

cat2verilog 支援以下 DSL 語法：

#### 物件宣告
```cat
object A
object B
object C
```

#### 態射宣告
```cat
morphism f: A -> B
morphism g: B -> C
morphism h: A -> C
```

#### 交換性斷言
```cat
assert commute: g ∘ f == h
```

### 完整範例

建立一個 `example.cat` 檔案：

```cat
object A
object B
object C

morphism f: A -> B
morphism g: B -> C
morphism h: A -> C

assert commute: g ∘ f == h
```

執行編譯：

```bash
./target/debug/cat2verilog example.cat example.v
```

### 生成的 Verilog

編譯器會生成以下 Verilog 程式碼：

```verilog
// Generated by cat2verilog
module top (
    input [7:0] in_A,
    input [7:0] in_B,
    input [7:0] in_C,
    output [7:0] out_A,
    output [7:0] out_B,
    output [7:0] out_C
);

// Morphism f: A -> B
assign out_B = in_A + 1; // Placeholder logic
// Morphism g: B -> C
assign out_C = in_B + 1; // Placeholder logic
// Morphism h: A -> C
assign out_C = in_A + 1; // Placeholder logic

endmodule
```

## 專案結構

```
cat2verilog/
├── Cargo.toml          # 專案配置與依賴
├── README.md           # 專案說明文件
├── src/
│   ├── main.rs         # CLI 主程式
│   ├── ast.rs          # 抽象語法樹定義
│   ├── parser.rs       # DSL 解析器
│   └── dag.rs          # DAG 和 Netlist 生成
├── example.cat         # 範例輸入檔案
└── example.v           # 生成的 Verilog 檔案
```

## 技術架構

### 編譯流程

```
.cat 檔案 → Parser → AST → DAG → Verilog
```

1. **Parser** - 使用 nom 解析器組合子解析 DSL
2. **AST** - 建立範疇論的抽象語法樹
3. **DAG** - 將範疇論轉換為有向無環圖
4. **Verilog** - 生成可模擬的硬體描述語言

### 核心概念

- **物件 (Objects)** - 代表電路的輸入/輸出端口
- **態射 (Morphisms)** - 代表組合邏輯電路
- **合成 (Composition)** - 態射的串接組合
- **交換性 (Commutativity)** - 確保不同路徑產生相同結果

## 進階用法

### 複雜的交換圖

```cat
object X
object Y
object Z
object W

morphism f: X -> Y
morphism g: Y -> Z
morphism h: X -> W
morphism i: W -> Z

assert commute: g ∘ f == i ∘ h
```

### 多態射合成

```cat
object A
object B
object C
object D

morphism f: A -> B
morphism g: B -> C
morphism h: C -> D
morphism k: A -> D

assert commute: h ∘ g ∘ f == k
```

## 開發指南

### 新增態射類型

要支援新的態射類型，需要修改：

1. `src/ast.rs` - 新增 AST 節點類型
2. `src/parser.rs` - 新增解析規則
3. `src/dag.rs` - 新增 Verilog 生成邏輯

### 測試

```bash
# 執行所有測試
cargo test

# 執行特定測試
cargo test test_parser

# 檢查程式碼
cargo check
```

## 限制與未來改進

### 目前限制

- 態射邏輯目前使用簡單的 placeholder
- 不支援遞迴或循環結構
- 交換性驗證僅為基本檢查

### 未來改進

- [ ] 支援更複雜的態射邏輯
- [ ] 自動交換性驗證
- [ ] 測試向量生成
- [ ] 電路優化
- [ ] 支援更多範疇論概念

## 貢獻

歡迎提交 Issue 和 Pull Request！

### 開發環境設定

```bash
# 安裝 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 安裝依賴
cargo install cargo-edit

# 開發模式
cargo watch -x run -- example.cat example.v
```

## 授權

MIT License - 詳見 [LICENSE](LICENSE) 檔案

## 參考資料

- [範疇論基礎](https://en.wikipedia.org/wiki/Category_theory)
- [Verilog 語言參考](https://en.wikipedia.org/wiki/Verilog)
- [Rust 程式語言](https://www.rust-lang.org/)
- [nom 解析器組合子](https://github.com/Geal/nom)

---

**cat2verilog** - 讓範疇論與硬體設計相遇 🚀 