use std::fs;
use std::env;

#[derive(Debug)]
enum Statement {
    Object(String),
    Morphism { name: String, from: String, to: String },
    AssertCommute { lhs: Vec<String>, rhs: Vec<String> },
}

fn parse_line(line: &str) -> Option<Statement> {
    let line = line.trim();
    if line.is_empty() { return None; }
    
    if line.starts_with("object ") {
        let name = line[7..].trim().to_string();
        Some(Statement::Object(name))
    } else if line.starts_with("morphism ") {
        let parts: Vec<&str> = line[9..].split(":").collect();
        if parts.len() != 2 { return None; }
        let name = parts[0].trim().to_string();
        let arrow_parts: Vec<&str> = parts[1].split("->").collect();
        if arrow_parts.len() != 2 { return None; }
        let from = arrow_parts[0].trim().to_string();
        let to = arrow_parts[1].trim().to_string();
        Some(Statement::Morphism { name, from, to })
    } else if line.starts_with("assert commute:") {
        let parts: Vec<&str> = line[15..].split("==").collect();
        if parts.len() != 2 { return None; }
        let lhs: Vec<String> = parts[0].split("∘").map(|s| s.trim().to_string()).collect();
        let rhs: Vec<String> = parts[1].split("∘").map(|s| s.trim().to_string()).collect();
        Some(Statement::AssertCommute { lhs, rhs })
    } else {
        None
    }
}

fn generate_verilog(statements: &[Statement]) -> String {
    let mut verilog = String::new();
    verilog.push_str("// Generated by cat2verilog\n");
    verilog.push_str("module top (\n");
    
    // Find all objects
    let mut objects = Vec::new();
    for stmt in statements {
        if let Statement::Object(name) = stmt {
            objects.push(name);
        }
    }
    
    // Add inputs and outputs
    for (i, obj) in objects.iter().enumerate() {
        verilog.push_str(&format!("    input [7:0] in_{}", obj));
        if i < objects.len() - 1 { verilog.push_str(","); }
        verilog.push_str("\n");
    }
    for (i, obj) in objects.iter().enumerate() {
        verilog.push_str(&format!("    output [7:0] out_{}", obj));
        if i < objects.len() - 1 { verilog.push_str(","); }
        verilog.push_str("\n");
    }
    
    verilog.push_str(");\n\n");
    
    // Add morphism logic
    for stmt in statements {
        if let Statement::Morphism { name, from, to } = stmt {
            verilog.push_str(&format!("    // Morphism {}: {} -> {}\n", name, from, to));
            verilog.push_str(&format!("    assign out_{} = in_{} + 1; // Placeholder logic\n", to, from));
        }
    }
    
    verilog.push_str("endmodule\n");
    verilog
}

fn main() {
    let args: Vec<String> = env::args().collect();
    
    if args.len() != 3 {
        eprintln!("Usage: {} <input.cat> <output.v>", args[0]);
        eprintln!("Example: {} example.cat example.v", args[0]);
        std::process::exit(1);
    }
    
    let input_file = &args[1];
    let output_file = &args[2];
    
    // Read input file
    let input_content = match fs::read_to_string(input_file) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Error reading input file: {}", e);
            std::process::exit(1);
        }
    };
    
    println!("Parsing category theory description from: {}", input_file);
    
    // Parse the file
    let mut statements = Vec::new();
    for (i, line) in input_content.lines().enumerate() {
        if let Some(stmt) = parse_line(line) {
            statements.push(stmt);
            println!("  {}: {:?}", i + 1, stmt);
        }
    }
    
    println!("Successfully parsed {} statements", statements.len());
    
    // Generate Verilog
    println!("Generating Verilog...");
    let verilog_code = generate_verilog(&statements);
    
    // Write output file
    match fs::write(output_file, verilog_code) {
        Ok(_) => println!("Successfully generated Verilog: {}", output_file),
        Err(e) => {
            eprintln!("Error writing output file: {}", e);
            std::process::exit(1);
        }
    }
    
    println!("Compilation Summary:");
    println!("  Input:  {}", input_file);
    println!("  Output: {}", output_file);
    println!("  Objects: {}", statements.iter().filter(|s| matches!(s, Statement::Object(_))).count());
    println!("  Morphisms: {}", statements.iter().filter(|s| matches!(s, Statement::Morphism { .. })).count());
} 